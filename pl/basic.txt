== Podstawowe sztuczki ==

Zamiast nurkować od razu w morzu poleceń Git, używaj na początek tych podsawowych przykładów. Każdy z nich jest użyteczny mimo swojej prostoty. Tak naprawdę w pierwszych miesiącach mojej przygody z Git nigdy nie wyszedłem poza materiał z tego rozdziału.

=== Zapisywanie Stanu ===

Zamierzasz zrobić coś drastycznego? Zanim to zrobisz, wykonaj migawkę wszystkich plików w aktualnym katalogu poleceniem:

 $ git init
 $ git add .
 $ git commit -m "Mój pierwszy backup"

Teraz, jeśli Twoje edycje okazały się chybione, przywróć poprzednią, nieskazitelną wersję:

 $ git reset --hard

Aby znowy zapisan stan:

 $ git commit -a -m "Kolejny backup"

=== Dodaj, Usuń, Zmień nazwę ===

Poprzedni paragraph odnosi się jedynie do plików, które istnieją kiedy pierwszy raz wykonujesz *git add*. Jeśli dodasz nowe pliki lub podkatalogi, będziesz musiał poinformować o tym Git:

 $ git add readme.txt Documentation

Analogicznie, jeśli będziesz chciał aby Git zapomniał o pewnych plikach:

 $ git rm kludge.h obsolete.c
 $ git rm -r incriminating/evidence/

Jeśli sam nie usunąłeś wcześniej tych plików, Git zrobi to za Ciebie.

Zmiana nazwy pliku jest tym samym co usunięcie starej nazwy I dodanie nowej. Istnieje do tego skrót *git mv*, który ma taką samą składnię jak polecenie *mv*, na przykład: 

 $ git mv bug.c feature.c

=== Zaawansowane  Cofnij/Przywróć ===

Czasami chcesz po prostu wrócić do porzedniej wersji I zapomnieć o wszystkich zmianach, które po niej nastąpiły, ponieważ wszystkie były błędne. Robisz wtedy tak:

 $ git log

Pokazuje Ci listę ostatnich commits (zapisów) i ich sumy kontrolne SHA1:


----------------------------------
commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob <bob@example.com>
Date:   Tue Mar 14 01:59:26 2000 -0800

    Replace printf() with write().

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice <alice@example.com>
Date:   Thu Jan 1 00:00:00 1970 +0000

    Initial commit.
----------------------------------

Pierwsze kilka znaków sumy kontrolnej wystarczą aby jednoznacznie określić commit, alternatywnie możesz skopiować i wkleić całą sumę. Napisz: 

 $ git reset --hard 766f

Żeby przywrócić stan konkretnego commit’a i wymazać nieodwracalnie wszystkie nowsze od niego.

Innym razem możesz chcieć jedynie skoczyć na chwilę do poprzedniego stanu. W taki przypadku użyj napisz:

 $ git checkout 82f5

To polecenie zabierze Cię z powrotem w czasie, ale zachowuje wszystko co się stało później. Jednakże, tak jak z podróżami w czasie w filmach science-fiction, jeśli teraz coś zmienisz to znajdziesz się w alternatywnej rzeczywistości, ponieważ Twoje zmiany są inne niż te, stworzone kiedy tu byłeś pierwszy raz. 

Ta alternatywna rzeczywistość nazywa się 'branch' ( gałąź ) i <<branch, o niej pomówimy później>>. Na razie, po prostu zapamiętaj, że 

 $ git checkout master

zabierze Cię z powrotem do teraźniejszości. Dodatkowo, żeby Git przestał narzekać, zawsze wykonuj polecenie commit lub reset przed używaniem checkout. 

Przekładając to na analogię do gry komputerowej: 

- *`git reset --hard`*: wczytaj stary save i usuń wszystkie nowsze od niego.

- *`git checkout`*: wczytaj starą grę, ale jeśli zagrasz, to stan gry zmieni się w stosunku do poprzedniego i zapisów gry które powstały po nim. Jakiekolwiek zapisy gry znajdą się w nowym branch ( gałęzi ) odzwierciedlającej alternatywną rzeczywistość, w któ®ej się znalazłeś. <<branch, Tym zajmiemy się później>>.

Możesz wybrać tylko konkretne pliku I podkatalogi, które chcesz przywrócić, przez podanie ich nazw na końcu polecenia:

 $ git checkout 82f5 some.file another.file

Uważaj, bo taka forma *checkout* możę po cichu nazpisać pliki. Żeby zapobiec wypadkom, zawsze wykonuj commit przed używaniem jakiekolwiek komendy checkout, zwłaszcza gdy się uczysz Git. Co do zasady, zawsze kiedy nie jesteś pewny wyniku jakiejś komendy, najpierw użyj polecenia *git commit -a*.

Nie lubisz kopiowania i wklejania sum konrolnych? Możesz użyć: 

 $ git checkout :/"My first b"

żeby przeskoczyć do commit’a, który zaczyna się od podanej wiadomości. Możesz również poprosić o powrót do 5-tego liczonego od najświeższego zapisanego stanu:

 $ git checkout master~5

=== Reverting ===

In a court of law, events can be stricken from the record. Likewise, you can pick specific commits to undo.

 $ git commit -a
 $ git revert 1b6d

will undo just the commit with the given hash. The revert is recorded as a new
commit, which you can confirm by running *git log*.

=== Changelog Generation ===

Some projects require a http://en.wikipedia.org/wiki/Changelog[changelog].
Generate one by typing:

 $ git log > ChangeLog

=== Downloading Files ===

Get a copy of a project managed with Git by typing:

 $ git clone git://server/path/to/files

For example, to get all the files I used to create this site:

 $ git clone git://git.or.cz/gitmagic.git

We'll have much to say about the *clone* command soon.

=== The Bleeding Edge ===

If you've already downloaded a copy of a project using *git clone*, you can upgrade to the latest version with:

 $ git pull

=== Instant Publishing ===

Suppose you've written a script you'd like to share with others. You could just tell them to download from your computer, but if they do so while you're improving the script or making experimental changes, they could wind up in trouble.  Of course, this is why release cycles exist. Developers may work on a project frequently, but they only make the code available when they feel it is presentable.

To do this with Git, in the directory where your script resides:

 $ git init
 $ git add .
 $ git commit -m "First release"

Then tell your users to run:

 $ git clone your.computer:/path/to/script

to download your script. This assumes they have ssh access. If not, run *git daemon* and tell your users to instead run:

 $ git clone git://your.computer/path/to/script

From now on, every time your script is ready for release, execute:

 $ git commit -a -m "Next release"

and your users can upgrade their version by changing to the directory containing your script and typing:

 $ git pull

Your users will never end up with a version of your script you don't want them to see.

=== What Have I Done? ===

Find out what changes you've made since the last commit with:

 $ git diff

Or since yesterday:

 $ git diff "@{yesterday}"

Or between a particular version and 2 versions ago:

 $ git diff 1b6d "master~2"

In each case the output is a patch that can be applied with *git apply*.
Try also:

 $ git whatchanged --since="2 weeks ago"

Often I'll browse history with http://sourceforge.net/projects/qgit[qgit] instead, due to its slick photogenic interface, or http://jonas.nitro.dk/tig/[tig], a text-mode interface that works well over slow connections. Alternatively, install a web server, run *git instaweb* and fire up any web browser.

=== Exercise ===

Let A, B, C, D be four successive commits where B is the same as A except some files have been removed. We want to add the files back at D. How can we do this?

There are at least three solutions. Assuming we are at D:

  1. The difference between A and B are the removed files. We can create a patch representing this difference and apply it:

   $ git diff B A | git apply

  2. Since we saved the files back at A, we can retrieve them:

   $ git checkout A foo.c bar.h

  3. We can view going from A to B as a change we want to undo:

   $ git revert B

Which choice is best? Whichever you prefer most. It is easy to get what you want with Git, and often there are many ways to get it.
