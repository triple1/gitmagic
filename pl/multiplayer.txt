== Git Multiplayer ==

Początkowo używałem Git we własnych projektach, w których byłem jedynym deweloperem. Spośród poleceń związanych z rozproszonym charakterem Git, potrzebowałem jedynie * pull * i * clone * żebym mógł przechowywać ten sam projekt w różnych miejscach.

Później chciałem opublikować mój kod za pomocą Git i zawrzeć zmiany innych. Musiałam nauczyć się jak zarządzać projektami z wieloma deweloperami z całego świata. Na szczęście, jest to Git mocna strona Git, oraz jego raison d'être (racja istnienia).

=== Kim Jestem? ===

Każdy commit jest opatrzony nazwą autora oraz emailem, które mogą być pokazane pokazany za pomocą * git log *.
Domyślnie, Git używa ustawień systemowych w celu uzupełnienia tych pól.
Aby je ustawić, należy wpisać:

  $ git config - global user.name "John Doe"
  $ git config - global johndoe@example.com user.email

Pomiń flagę global żeby ustawić te opcje tylko dla aktualnego repozytorium.

=== Git przez SSH, HTTP ===

Załóżmy, że masz dostęp przez SSH na serwer, ale Git nie jest zainstalowany. Jakkolwiek mniej efektywne niż jego macierzystym protokołem, Git może komunikować się za pośrednictwem protokołu HTTP.

Pobierz, skompiluj i zainstaluj Git na koncie, i stwórz repozytorium w swoim katalogu zawierającym stronę internetową:

 $ GIT_DIR git init = proj.git
 $ cd proj.git
 $ git - bare update-server-info
 $ cp hooks / post-update.sample hooks / post-update

W przypadku starszych wersji Git, polecenie kopiowania nie powiedzie się, a zamiast niego powinieneś wykonać:

 $ chmod + x hooks / post-update

Teraz możesz publikować swoje najnowsze edycje przez SSH z dowolnego klona:

 $ git web.server push: / ścieżka / do / proj.git master

i każdy może ściągnąć Twój projekt:

 $ git clone http://web.server/proj.git

=== Git Poprzez Wszystko ===

Chcesz synchronizować repozytoria bez serwerów, a nawet połączenia sieciowego?
Musisz improwizować w sytuacji kryzysowej? Widzieliśmy <<makinghistory, * git fast-export * i * git fast-import * szybko mogą konwertować repozytoria do jednego pliku i z powrotem.>> Moglibysmy przerzucać takie pliki w tę i z powrotem, aby transportować repozytoria git, używając dowolnego nośnika, ale bardziej skutecznym narzędziem jest * git bundle *.

Nadawca tworzy "bundle":

 $ git bundle create somefile HEAD

następnie przenosi pakiet, + somefile +, do drugiej osoby za pomocą: emaila, pendrive’a, wydruku * xxd * i skanera OCR, czytając bity przez telefon, sygnałami dymnymi itp. Odbiorca pobiera commit’y z bundle wpisując:

 $ git pull somefile

Odbiorca może to zrobić nawet z pustego repozytorium. Pomimo
rozmiaru, + somefile + zawiera całe oryginalne repozytorium git.


Przy większych projektach można wyeliminować zmarnowane miejsce poprzez przygotowywanie bundle wyłącznie ze zmian, jakich drugie repozytorium nie ma. Załóżmy na przykład, commit `` 1b6d ...'' jest ostatnią zmianą wspólną dla obu stron:

 $ git bundle create somefile 1b6d HEAD ^

Jeśli robimy to często, możemy łatwo zapomnieć, który commit ostatnio wysłaliśmy.
Strona pomocy sugeruje użycie tagów, aby rozwiązać ten problem. Mianowicie, po wysłaniu pakietu, napisz:

 $ git tag -f lastbundle HEAD

i tworzenia nowych pakietów za pomocą:

 $ git bundle create newbundle ^ lastbundle HEAD

=== Patche: Globalny ===

Poprawki są tekstowe reprezentacje zmiany, które mogą być zrozumiałe
przez komputery i ludzi. To daje im uniwersalny. Można e-mail
patch do twórców bez względu na system kontroli wersji korzystają. Tak długo,
jak odbiorcy mogą czytać e-maili, widzą zmiany. Podobnie na
boku, wszystko czego wymaga konta e-mail: nie ma potrzeby, aby ustawić online repozytorium Git.

Przypomnijmy, w pierwszym rozdziale:

 $ Git diff my.patch 1b6d>

wyjść patch, który można wkleić do e-maila do dyskusji. W Git


 $ Git zastosować <my.patch

do zastosowania tej poprawki.

W bardziej formalnych ustawienia, kiedy nazwiska autorów i być może podpisów
rejestrowane, generuje odpowiednie patche przeszłości pewnym momencie, wpisując:

 $ Git format-patch 1b6d

Pliki wynikowe można podawać * git-wyślij email * lub wysłać ręcznie. Możesz także określić zakres zobowiązuje się:

 $ Git format-patch 1b6d .. ^ ^ HEAD

Na koniec otrzymania, chyba e-mail do pliku, a następnie wpisz:

 $ Git am <email.txt

Dotyczy to patch przychodzących, a także tworzy zobowiązania, w tym informacje, takie jak autor.

Z klienta poczty przeglądarkę, należy kliknąć przycisk, aby zobaczyć e-mail w swej surowej postaci oryginalny przed zapisaniem patch do pliku.

Istnieją niewielkie różnice w mbox, klienci e-mail, ale jeśli masz jedno
z nich, prawdopodobnie jesteś osobą, która może ich liczba łatwo
bez czytania tutoriale!

=== Niestety, zostały przeniesione ===


push pull lub z oryginalnego adresu URL. Jak Git to zrobić? Sekret tkwi w
Weźmy okiem:

 $ Git config - list

+ Remote.origin.url + opcja kontroluje URL źródła pochodzenia''`` jest nick
uwagę na repozytorium. Podobnie jak w przypadku pana''`` konwencji branży, może
zmienić lub usunąć ten nick, ale zwykle nie ma powodu do tego.

Jeśli oryginalny porusza repozytorium, możemy zaktualizować adres URL przez:

 $ Git config remote.origin.url git: / / new.url / proj.git

+ Branch.master.merge + opcja określa domyślną zdalnego oddział w
* git pull *. W początkowym klon, jest ustawiony na bieżący oddział
repozytorium, więc nawet jeśli szef repozytorium następnie

oryginalny oddziału.

Ta opcja ma zastosowanie tylko do stron po raz pierwszy sklonowany z, która jest
zapisane w opcji + branch.master.remote +. Jeśli się ją wyciągnie z innych
repozytoriów musimy wyraźnie określić, które oddział chcemy:

 $ Git pull git: / / example.com / other.git master

Powyższe wyjaśnia dlaczego niektóre z naszych wcześniejszych siłą napędową przykładów nie ma
argumenty.

=== === Oddziałów zamiejscowych

Kiedy klon repozytorium, także klonować wszystkich swoich oddziałach. Możesz nie mieć
Zauważyłem to, ponieważ ukrywa Git je z daleka: musi poprosić o ich specjalnie.

swoje oddziały, a także, że Git łatwiejsze dla początkujących.

Lista oddziałów zamiejscowych z:

 $ Git branch-r

Powinieneś zobaczyć coś takiego:

 pochodzenia / HEAD
 pochodzenia / master
 pochodzenia / experimental

Stanowią one oddziałów i szefa zdalnym repozytorium i mogą być używane
w normalnych komend Git. Na przykład załóżmy, że poczynili wiele zobowiązuje, a
chcesz porównać z ostatnio pobrane wersji. Można przeszukiwać
loguje do odpowiedniego skrótu SHA1, ale o wiele łatwiej wpisać:

 $ Git diff pochodzenia / HEAD

Można też zobaczyć, co `` eksperymentalnej gałęzi''została do:

 $ Git log pochodzenia / experimental

=== Wiele Pilot ===

Załóżmy, że dwóch innych deweloperów pracuje nad naszym projektem, a my chcemy
zachować zakładki na obu. Możemy śledzić więcej niż jedno repozytorium w czasie z:

 $ Git zdalnego dodać inne git: / / example.com / some_repo.git
 $ Git pull innych some_branch

Teraz połączyły się w oddział z drugiej stron, a mamy
łatwy dostęp do wszystkich działów wszystkie repozytoria:

 $ Git diff pochodzenia / experimental ^ inne / some_branch ~ 5

Ale co, jeśli chcemy tylko, aby porównać ich zmian bez wpływu na własne
pracy? Innymi słowy, chcemy zbadać ich oddziałów bez
zmiany w ich inwazji na nasz katalog. Wtedy zamiast ciągnąć, wykonaj:

 $ Git fetch # Fetch pochodzenia, domyślnie.
 $ Git fetch innych # Fetch z drugim programistą.

To właśnie pobiera historii. Mimo że katalog roboczy pozostaje nietknięty,
można znaleźć na każdym oddziale w każdym repozytorium Git polecenia, bo teraz
posiada lokalną kopię.


Zwykle * * ciągnąć, bo chcemy się połączyć najnowsze popełnić po sprowadzić;
tej sytuacji jest chlubnym wyjątkiem.

Zobacz git pomocy pilota * * dla jak usunąć zdalnych repozytoriach, zignorować pewne
oddziałów i więcej.

=== === My Preferences


pull. Niektóre Git usług hostingowych pozwala gospodarzem własnego widelec projektu z


Po tym, jak pobrać drzewa, biegam Git poleceń do nawigacji i analizy zmian,
, które idealnie są dobrze zorganizowane i dobrze opisane. Mogę połączyć moje własne zmiany,
i być może dokonać dalszych zmian. Po stwierdzeniu, wciskam do głównego repozytorium.

Choć rzadko otrzymują dotacje, wierzę, że łuski podejście
dobrze. Zobacz
http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html [to
blog post przez Linus Torvalds].

Pobyt w świecie Git jest nieco wygodniejsze niż pliki poprawki, ponieważ
ratuje mnie z ich konwersją do git. Ponadto, Git uchwyty szczegóły
takich jak nagrywanie nazwisko autora i adres e-mail, jak również czasu i
data i zwraca się do autora na temat ich własnych zmian.
