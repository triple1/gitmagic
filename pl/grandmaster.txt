== Grandmastery Git ==

Do tej pory powinieneś już być w stanie swobodnie się poruszać po stronach pomocy * git *  i zrozumieć prawie wszystko. Jednak dokładne określenie polecenia potrzebnego do rozwiązania danego problemu może być trudne. Być może mogę zaoszczędzić Ci trochę czasu: poniżej jest kilka receptur, które były mi potrzebne w przeszłości.

=== Wydania źródłowe ===

W moich projektach, Git śledzi jedynie pliki, które chcę archiwizować i udostępniać użytkownikom. Aby utworzyć archiwum z kodem źródłowym, wpisuję:

 $ git archive --format=tar --prefix=proj-1.2.3/ HEAD

=== Zatwierdzam to co się zmieniło ===

Informowanie Git kiedy dodaliśmy, usunęliśmy lub zmieniliśmy nazwę plików jest uciążliwe w przypadku niektórych projektów. Zamiast tego, możesz wpisać:

 $ git add .
 $ git add -u

Git będzie przejrzy pliki w bieżącym katalogu i sam dopracuje szczegóły. Zamiast drugiego polecenia add, wykonaj `git commit -a`, jeśli zamierzasz wykonać commit tym razem. Informacje o tym jak określić pliki, które ają być ingorowane znajdziesz w * gir help ignore *.

Powyższe operacje możesz wykonać za jednym razem:

 $ git ls-files –d –m –o -z | xargs -0 git update-index --add --remove

Opcje *- Z * i *- 0 * zapobiegają dziwnym skutkom ubocznym dodawania plików o nazwach zawierających dziwne znaki. Jak, że to polecenie dodaje ignorowane pliki, możesz chcieć skorzystać z opcji `-X` lub `-X`.

=== Mój Commit jest zbyt duży! ===

Czy zbyt długo zapominałeś wykonywać commit? Czy wściekle pisałęś kod i zapomniałeś o kontroli wersji aż do teraz? Wykonałeś szereg niepowiązanych zmian, ponieważ taki jest twój styl?

Nie martw się. Wykonaj:

 $ git add -p

Dla każdej edycji, którą wykonałeś, git pokaże kawałek kodu, który został zmieniony i zapyta, czy powinien należeć on do następnego commit. Odpowiedź "y" lub "n". Masz też inne opcje, takie jak odroczenie decyzji; napisz "?" aby dowiedzieć się więcej.

Gdy jesteś zadowolony, napisz:

 $ git commit

Aby wykonać commit dokładnie wybranych zmian ("staged" changes). Upewnij się, że pominąłeś opcję * -a *, w przeciwnym razie git wykona commit wszystkich zmian.

Co jeśli edytowałeś wiele plików w wielu miejscach? Przeglądanie każdej zmiany staje się frustrujące i paraliżujące umysł. W tym przypadku należy użyć git * add -i *, którego interfejs jest bardziej skomplikowany, ale bardziej elastyczny. za pomocą kilku klawiszy,
można wykonać stage lub unstage na kilku plikach jednocześnie, lub przejrzeć i wybrać zmiany jedynie w konkretnych plikach. Alternatywnie, uruchom komendę * git commit --interactive *, która to automatycznie wykonuje commit po zakończeniu.

=== Indeks: obszar staging Git ===

Do tej pory unikaliśmy słynnego "Index" w Git, ale teraz musimy się z nim zmierzyć, żeby wyjaśnić powyższe. Indeks jest tymczasowym obszarem stage. Git rzadko przerzuca dane bezpośrednio pomiędzy projektem i jego historią. Raczej najpierw zapisuje dane do indeksu, a następnie kopiuje dane z niego do miejsca docelowego.

Na przykład, * commit -a * jest naprawdę procesem dwuetapowym. W pierwszym kroku umieszcza aktualny stan każdego pliku do indeksu. W drugim kroku na stałe zapisuje aktualny stan, który jest obecnie w indeksie. Wykonywanie commit bez opcji * -a * wykonuje tylko drugi krok, i ma sens tylko po wykonaniu poleceń, które w jakiś sposób zmieniają  indeks, takich jak * git add *.

Zazwyczaj możemy ignorować indeks i udawać, że czytamy i zapisujemy prosto z historii. W przypadku gdybyśmy chcieli mieć większą kontrolę, możemy manipulować indeksem. Umieszczamy aktualny stan niektórych, ale nie wszystkich, naszych zmian do indeksu, a następnie na stałe zapisujemy tą dokładnie spreparowaną migawkę.

=== Nie trać głowy (HEAD) ===

Znacznik HEAD jest jak kursor, który wskazuje na ostatni commit, i przesuwa się naprzód z każdym nowym commit. Niektóre komendy git pozwalają go przesunąć. Na przykład:

 $ git reset HEAD~3

przeniesie HEAD trzy commit’y do tyłu. Tak więc wszystkie polecenia git teraz działać tak, jakby te trzy ostatnie commit’y nie istniały, a twoje pliki pozostaną w teraźniejszości. Zobacz stronę pomoc dla niektórych zastosowań.

Ale jak można wrócić do przyszłości? Commit’y w przeszłości nic nie wiedzą o przyszłości.

Jeśli masz SHA1 oryginalnego HEAD możesz wykonać:

 $ git reset 1b6d

Ale załóżmy, że nigdy go nie zanotowaliśmy? Nie martw się: dla poleceń takich jak te, Git zapisuje oryginalny HEAD jako zmienną ORIG_HEAD, więc możesz powrócić cały i zdrowy poleceniem:

 $ git reset ORIG_HEAD

=== Polowania na głowy ===

Być może ORIG_HEAD nie wystarczy. Być może już sobie sprawę dokonane monumentalny błąd i trzeba wrócić do dawnych popełnić w oddziale dawno zapomniane.

Domyślnie, Git prowadzi popełnienia przez co najmniej dwa tygodnie, nawet w przypadku zamówienia
Git, by zniszczyć gałęzi, które ją zawierają. Problem polega na znalezieniu odpowiedniego
hash. Możemy spojrzeć na wszystkie wartości hash w `.git / obiektów` i metodą prób
i błąd, który chcesz. Ale jest znacznie łatwiejszy sposób.

Git rejestruje każde hash popełnić to oblicza się w `.git / logs`. Podkatalogu `bibl.` zawiera historię wszystkich działań na wszystkich oddziałach, podczas gdy plik `HEAD` pokazuje wszystkie wartości hash kiedykolwiek podjąć. Ta ostatnia może być używany do mieszania z popełnia na oddziały, które zostały przypadkowo Odciął.

Komenda reflog zapewnia przyjazny interfejs do tych plików dziennika. Wypróbować

  $ Git reflog

Zamiast wycinać i wklejać skróty z reflog, spróbuj:

 $ Git checkout "@ {10 minuty temu}"

Lub kasy na 5. ostatniej wizyty popełnienia przez:

 $ Git checkout "@ {5}"

Zobacz `` Określanie Wersje''części git * pomóc rev-parse * więcej.

Możesz skonfigurować dłuższy okres łaski dla skazanych zobowiązuje. Dla
przykład:

  $ Git config gc.pruneexpire "30 dni"

oznacza usunięte popełnienia będą utracone po upływie 30 dni
i git gc * * jest uruchamiany.

Możesz również wyłączyć automatyczne wywołanie * git gc *:

  $ Git config gc.auto 0

w takim przypadku zobowiązuje będą usuwane po uruchomieniu * git gc * ręcznie.

Budowa === W === Git

W prawdziwie UNIX, Git jest budowa pozwala mu być łatwo wykorzystane jako niski poziom składnika innych programów, takich jak GUI i interfejs sieciowy, alternatywnych linii poleceń interfejsy, narzędzia zarządy patch, importowanie i narzędzi do konwersji i tak dalej. W rzeczywistości, niektóre polecenia Git same skrypty stojąc na ramionach olbrzymów. Przy odrobinie majsterkowania, można dostosować Git do własnych preferencji.

Jednym z prostszych Sztuczka polega na użyciu wbudowane aliasy Git skrócić najczęściej
używane polecenia:

  $ Git config - global alias.co kasie
  $ Git config - global - get-regexp alias # wyświetlania bieżącego aliasy
  alias.co kasie
  $ Git co foo # to samo co 'git checkout foo'

Innym sposobem jest wydrukowanie bieżącego oddziału w tytule polecenia lub okna.
Wywoływanie

  $ Git symboliczne-ref HEAD

pokazuje aktualną nazwę oddziału. W praktyce, prawdopodobnie chcesz usunąć
"bibl. / głowy /" i ignoruj błędy:

  $ Git symboliczne-ref HEAD 2> / dev / null | cut-b 12 -

+ + Podkatalogu contrib jest skarbnicą narzędzi zbudowany na Git.
W czasie, niektóre z nich mogą być promowane do oficjalnych poleceń. Na Debianie i
Ubuntu, ten katalog mieszka w + / usr / share / doc / git-core / contrib +.

Jednym z popularnych rezydenta + workdir / git-new-workdir +. Via sprytny symbolicznego, skrypt utworzy nowy katalog, którego historia jest wspólna z oryginalnego repozytorium:

  $ Git-new-workdir / istniejące / repo nowego / katalogu

Nowy katalog i pliki w mogą być traktowane jako klon, z wyjątkiem ponieważ historia jest wspólna, dwa drzewa automatycznie pobyt w synchronizacji. Nie ma potrzeby łączenia, push, lub ciągnąć.

=== Daring Stunts ===

Te dni, Git utrudnia użytkownikowi przypadkowo zniszczyć dane.
Ale jeśli wiesz, co robisz, można zastąpić zabezpieczenia wspólnych
poleceń.

* Zamówienie *: Niezakończone powodują zmiany kasy na porażkę. Aby zniszczyć zmiany, a kasy danego popełnić tak, należy użyć flagi życie:

  $ Git checkout-f HEAD ^

Z drugiej strony, jeśli podasz konkretne kierunki dla kasy, to nie ma żadnych kontroli bezpieczeństwa. Dostarczone ścieżki są cicho nadpisane. Uważaj, jeśli używasz realizacji transakcji w ten sposób.

* Reset *: Reset też nie w obecności niezatwierdzone zmiany. Aby wymusić to poprzez uruchom:

  $ Git reset - hard 1b6d

* Oddział *: Usuwanie gałęzi nie gdy powoduje to zmiany zostaną utracone. Aby wymusić usunięcie, typu:

  $ Git branch-D dead_branch # zamiast-d

Podobnie, próbując zastąpić oddział poprzez przenoszenie nie powiedzie się, jeśli utraty danych wyniknie. Aby wymusić ruch gałęzi, typu:

  $ Git branch-M cel źródłowy # zamiast-m

W przeciwieństwie do kasy i reset, te dwa polecenia odroczyć zniszczenia danych.
zmiany są nadal przechowywane w. git podkatalogu, i mogą być pobierane przez
odzyskiwanie odpowiednich skrót od `.git / logs` (patrz "łowców głów" powyżej).
Domyślnie, będą przechowywane przez co najmniej dwa tygodnie.

* Czystość *: Niektóre polecenia git odmowie nadania, gdyż martwią się o
przebijania nieśledzonej plików. Jeżeli jesteś pewien, że wszystkie nieśledzonej plików i
katalogi są zbędni, a następnie usunąć je bezlitośnie z:

  $ Git czyste-f-d

Następnym razem, polecenie to brzydkie będzie działać!

=== Zapobieganie Bad Zatwierdza ===

Głupich błędów zanieczyszczają moich repozytoriów. Najbardziej przerażające są brakujące pliki z powodu
do zapomnianego git * dodać *. Lesser grzechy są końcowe białe znaki i
nierozwiązane konflikty podczas scalania: choć nieszkodliwe, pragnę, to nigdy nie pojawił się na
publicznej.

Gdybym tylko wykupił ubezpieczenie idiota za pomocą _hook_ poinformować mnie o tych problemów:

 $ Cd .git / haki
 $ Cp pre-pre-commit commit.sample # Starsze wersje Git: chmod + x pre-commit

Teraz Git przerywa zatwierdzenie wtedy bezużyteczny białe lub nierozwiązane konflikty połączyć się
wykryte.

Z tego przewodnika, w końcu dodaje się następujące do początku
* Pre-commit * hak do ochrony przed roztargnienia:

 jeśli git ls-files-o | grep '\ txt $. ", a następnie
   echo FAIL! Nieśledzone. Plików txt.
   exit 1
 fi

Kilka operacji git haki, patrz * git haki pomóc *. Mamy aktywowany
próbki * po aktualizacji * hak wcześniej przy omawianiu Git pośrednictwem protokołu HTTP. To działa
gdy głowa przemieszcza. Próbka po update aktualizuje pliki skryptów Git potrzeb
do komunikacji przez Git-agnostyk transportu, takich jak HTTP.
